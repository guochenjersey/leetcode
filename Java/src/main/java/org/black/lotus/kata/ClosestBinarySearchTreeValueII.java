package org.black.lotus.kata;


import org.black.lotus.marker.Amazon;
import org.black.lotus.marker.FirstRound;
import org.black.lotus.marker.Hard;
import org.black.lotus.marker.LintCode;

import java.util.List;


/**
 *
 * Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.

 Notice
 Given target value is a floating point.
 You may assume k is always valid, that is: k â‰¤ total nodes.
 You are guaranteed to have only one unique set of k values in the BST that are closest to the target.

 Example
 Given root = {1}, target = 0.000000, k = 1, return [1].

 Challenge
 Assume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)?

 TODO
 * */
@FirstRound
@Hard
@LintCode
@Amazon
public class ClosestBinarySearchTreeValueII {

    public List<Integer> closestKValues(TreeNode root, double target, int k) {
        return null;
    }
}
